# آزمایش هشتم - آزمایشگاه مهندسی نرم‌افزار
اعضای گروه: امیرحسین ندایی پور، علی مهربانی

## مرحله‌ی اول: پروژه ProfilingTest

در این بخش با استفاده از YourKit، فرایند profiling را بر روی کلاس JavaCup انجام می‌دهیم. اجرای کد با توجه به توابع موجود با خطای OutOfMemory روبرو می‌شود. درتصویر زیر می‌توان میزان استفاده از حافظه را مشاهده کرد:

![image](https://github.com/AliMehrabani/SEL-Week8/assets/59169318/ec5a645e-795b-46d4-9895-5110f006f8f6)

در نقطه‌ی پایانی انتخاب شده می‌بینیم که تابع temp در حال اجرا بوده است و برنامه هنگام اختصاص حافظه بیشتر به ArrayList موجود در این تابع با خطای مورد نظر مواجه شده است. در نتیجه باید تابع temp را تغییر داد. در تصویر زیر تابع تغییر یافته را مشاهده می‌کنید:(اعداد مربوط به حلقه‌ی تودرتو کاهش یافته‌اند)

![image](https://github.com/AliMehrabani/SEL-Week8/assets/59169318/a90d1d53-0b6d-403f-a2f0-8de66f353b45)

حال دوباره profiling را اجرا می‌کنیم:

![image](https://github.com/AliMehrabani/SEL-Week8/assets/59169318/8c6cf124-ce3b-4f27-b564-7e1fc8bf03ee)

همانطور که می‌بینیم، دیگر مشکل حافظه وجود ندارد و برنامه به اتمام می‌رسد.

## مرحله‌ی دوم: پروژه جدید

در این بخش ابتدا کد فیبوناچی را به صورت بازگشتی پیاده‌سازی می‌کنیم و از آن به صورت بخشی از یک حلقه بهره‌ می‌گیریم که در تصویر زیر قابل مشاهده است:

![image](https://github.com/AliMehrabani/SEL-Week8/assets/59169318/eb9213d8-113a-4946-91b4-d3cf6f27c85d)

حال اگر profiling را اجرا کنیم، میزان استفاده از cpu با ورودی دادن عدد 46 به صورت زیر خواهد شد:

![image](https://github.com/AliMehrabani/SEL-Week8/assets/59169318/f8a8d98e-da20-476d-b0cd-c6cccd57f9b5)

همانطور که در تصویر می‌بینیم، با جلو رفتن در حلقه، میزان استفاده از پردازنده بسیار سریع بالا می‌رود و تابع اجرا شده در این بازه طبق اطلاعات YourKit همان تابع fibonacci است. در نتیجه نیاز داریم این تابع را به صورتی بنویسیم که متناسب با بقیه‌ی کد از پردازنده استفاده کند. برای این کار تابع را به صورت غیربازگشتی پیاده‌سازی می‌کنیم:

![image](https://github.com/AliMehrabani/SEL-Week8/assets/59169318/15918607-97e2-4c45-9754-dae1a6e6efa4)

حال دوباره به ازای همان ورودی profiling را اجرا می‌کنیم:

![image](https://github.com/AliMehrabani/SEL-Week8/assets/59169318/fe4078da-97a3-49a8-b2c3-362fd3710030)

در تصویر بالا دیگر با روند افزایش مواجه نیستیم و همچنین زمان اجرای کد به میزان قابل ملاحظه‌ای کاهش یافته است. در حقیقت در اجرای دوم، نقطه‌ی شروع برنامه است که بیشترین استفاده را از پردازنده داشته است. لازم به ذکر است که حداکثر استفاده از پردازنده نسبت به اجرای اول، از مقدار 6 درصد به حدود 0.8 درصد کاهش یافته است.
